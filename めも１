// WebGL/Three.js Ink Splatter Animation Example
// Static final effect like ink stuck on wall

// Scene Setup
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.z = 2;
const renderer = new THREE.WebGLRenderer({antialias: true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Wall Background
const wallGeometry = new THREE.PlaneGeometry(10, 10);
const wallMaterial = new THREE.MeshBasicMaterial({color: 0xF5F5F5, side: THREE.DoubleSide});
const wall = new THREE.Mesh(wallGeometry, wallMaterial);
scene.add(wall);

// Particle System Setup
const particlesCount = 2000;
const particles = new THREE.BufferGeometry();
particles.setAttribute('position', new Float32Array(particlesCount * 3));
particles.setAttribute('color', new Float32Array(particlesCount * 3));
particles.setAttribute('size', new Float32Array(particlesCount));

const vertexData = particles.attributes.position.array;
const colorData = particles.attributes.color.array;
const sizeData = particles.attributes.size.array;

for (let i = 0; i < particlesCount; i++) {
    const x = 0, y = 0, z = 0;
    vertexData[i*3] = x;
    vertexData[i*3+1] = y;
    vertexData[i*3+2] = z;
    
    // Random initial colors
    colorData[i*3] = 0.0;
    colorData[i*3+1] = 0.0;
    colorData[i*3+2] = 1.0;
    
    // Random sizes
    sizeData[i] = Math.random() * 0.5 + 0.5;
}

// Shader Material for animated particles
const inkShader = new THREE.ShaderMaterial({
    type: 'points',
    color: 0x80FF00,
    size: 5,
    wireframeLinewidth: 1,
    vertexColors: true,
    blending: THREE.AdditiveBlending,
    depthTest: false,
    transparent: true,
    uniforms: {
        animationTime: { value: 0 },
        targetSpeed: { value: 20 },
        speedDecay: { value: 0.99 }
    },
    vertexShader: `
        uniform float animationTime;
        uniform float targetSpeed;
        uniform float speedDecay;

        attribute float size;
        attribute vec3 color;

        varying float vTime;
        varying vec4 vColor;
        varying float vSize;

        void main() {
            vec3 position = position;
            float currentTime = animationTime;
            
            // Particle animation
            float decay = pow(speedDecay, currentTime);
            float maxX = targetSpeed * decay;
            float maxY = targetSpeed * decay;
            
            float dx = (sin(currentTime * 0.5) * maxX) + (cos(currentTime * 1.2) * maxX);
            float dy = (cos(currentTime * 0.7) * maxY) + (sin(currentTime * 1.4) * maxY);
            
            // Random z movement
            float dz = (sin(currentTime * 2.5) * 0.5) + (cos(currentTime * 3) * 0.3);
            
            position.x += dx;
            position.y += dy;
            position.z += dz;
            
            // Color fading
            vTime = currentTime;
            vColor = vec4(color * 0.7, 1.0);
            vSize = size * 0.5;
            
            gl_PointSize = size * 2.0;
            gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);
        }
    },
    fragmentShader: `
        precision highp float;
        varying float vTime;
        varying vec4 vColor;
        varying float vSize;

        void main() {
            gl_FragColor = vec4(vColor, 1.0 - smoothstep(0.5, 0.5 + vTime, 1.0)) * (1.0 - vSize);
        }
    }
});

const inkMesh = new THREE.Points(particles, inkShader);
scene.add(inkMesh);

// Animation Loop
let lastTime = 0;
function animate(currentTime) {
    requestAnimationFrame(animate);
    
    currentTime *= 0.001; // Convert to seconds
    
    // Smooth time transition
    inkShader.uniforms.animationTime.value = Math.min(currentTime, 5);
    
    renderer.render(scene, camera);
}

// Start animation
animate();

// Mouse Movement Control
let mouse = new THREE.Vector2();
document.addEventListener('mousemove', (event) => {
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
});

rendering.addEventListener('mousemove', (event) => {
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
});

// Resize handler
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
